#!/usr/bin/env python3
"""
Memory Analysis Script for Weaviate Benchmarker

This script analyzes memory monitoring JSON files generated by the Weaviate benchmarker
and provides memory usage statistics and simplified visualizations.

Usage:
    python memory_analysis.py <memory_metrics_file.json>
    python memory_analysis.py results/memory_metrics_1234567890.json

Features:
- Memory usage over time visualization (all metrics)
- Memory usage distribution histogram (heap allocated)
- Peak, minimum, and average memory statistics
- Export plots as PNG files
"""

import json
import sys
import argparse
from datetime import datetime, timedelta
from pathlib import Path
from typing import List, Dict, Tuple

try:
    import matplotlib.pyplot as plt
    import matplotlib.dates as mdates
    HAS_MATPLOTLIB = True
except ImportError:
    HAS_MATPLOTLIB = False
    print("Warning: matplotlib not available. Plots will be disabled.")
    print("Install with: pip install matplotlib")


class MemoryAnalyzer:
    """Analyzes memory monitoring data from JSON files."""
    
    def __init__(self, filename: str):
        """Initialize the analyzer with a JSON file."""
        self.filename = filename
        self.metrics = self._load_metrics()
        self.timestamps = self._parse_timestamps()
        self._sort_by_timestamp()
        
    def _load_metrics(self) -> List[Dict]:
        """Load metrics from JSON file."""
        try:
            with open(self.filename, 'r') as f:
                metrics = json.load(f)
            
            if not metrics:
                raise ValueError("Empty metrics file")
                
            required_fields = ['timestamp', 'heap_alloc_bytes', 'heap_inuse_bytes', 'heap_sys_bytes']
            for metric in metrics[:1]:
                for field in required_fields:
                    if field not in metric:
                        raise ValueError(f"Missing required field: {field}")
            
            return metrics
        except FileNotFoundError:
            raise FileNotFoundError(f"Memory metrics file not found: {self.filename}")
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON format: {e}")
    
    def _parse_timestamps(self) -> List[datetime]:
        """Parse timestamps from metrics."""
        timestamps = []
        for i, metric in enumerate(self.metrics):
            try:
                timestamp_str = metric['timestamp']
                
                # Handle different timestamp formats
                if timestamp_str.endswith('Z'):
                    timestamp_str = timestamp_str[:-1] + '+00:00'
                
                # Handle microseconds with non-standard length (e.g., 5 digits instead of 6)
                if '.' in timestamp_str and '+' in timestamp_str:
                    parts = timestamp_str.split('.')
                    if len(parts) == 2:
                        microsec_and_tz = parts[1]
                        if '+' in microsec_and_tz:
                            microsec_part, tz_part = microsec_and_tz.split('+', 1)
                            microsec_part = microsec_part.ljust(6, '0')[:6]
                            timestamp_str = f"{parts[0]}.{microsec_part}+{tz_part}"
                        elif '-' in microsec_and_tz:
                            microsec_part, tz_part = microsec_and_tz.rsplit('-', 1)
                            microsec_part = microsec_part.ljust(6, '0')[:6]
                            timestamp_str = f"{parts[0]}.{microsec_part}-{tz_part}"
                
                timestamp = datetime.fromisoformat(timestamp_str)
                
                # Convert to UTC to ensure all timestamps are timezone-aware and comparable
                if timestamp.tzinfo is None:
                    timestamp = timestamp.replace(tzinfo=datetime.now().astimezone().tzinfo)
                
                timestamps.append(timestamp)
                
            except ValueError as e:
                print(f"Warning: Could not parse timestamp {metric['timestamp']}: {e}")
                base_time = datetime.now().replace(tzinfo=datetime.now().astimezone().tzinfo)
                placeholder = base_time + timedelta(seconds=i * 5)  # 5 second intervals
                timestamps.append(placeholder)
        
        return timestamps
    
    def _sort_by_timestamp(self):
        """Sort metrics and timestamps by chronological order."""
        paired_data = list(zip(self.timestamps, self.metrics))
        paired_data.sort(key=lambda x: x[0])  # Sort by timestamp
        
        self.timestamps, self.metrics = zip(*paired_data)
        self.timestamps = list(self.timestamps)
        self.metrics = list(self.metrics)
    
    def get_memory_data(self, metric_type: str) -> Tuple[List[datetime], List[float]]:
        """Get memory data for a specific metric type in MB."""
        if metric_type not in ['heap_alloc_bytes', 'heap_inuse_bytes', 'heap_sys_bytes']:
            raise ValueError(f"Invalid metric type: {metric_type}")
        
        values_mb = [metric[metric_type] / (1024 * 1024) for metric in self.metrics]
        return self.timestamps, values_mb
    
    def calculate_statistics(self, metric_type: str) -> Dict[str, float]:
        """Calculate statistics for a memory metric."""
        _, values_mb = self.get_memory_data(metric_type)
        
        if not values_mb:
            return {}
        
        return {
            'maximum': max(values_mb),
            'minimum': min(values_mb),
            'average': sum(values_mb) / len(values_mb),
            'peak_growth': values_mb[-1] - values_mb[0] if len(values_mb) > 1 else 0,
            'total_samples': len(values_mb)
        }
    
    def print_statistics(self):
        """Print comprehensive memory statistics."""
        print(f"\n{'='*80}")
        print(f"MEMORY ANALYSIS REPORT")
        print(f"{'='*80}")
        print(f"File: {self.filename}")
        print(f"Total samples: {len(self.metrics)}")
        
        # Verify timestamps are sorted
        is_sorted = all(self.timestamps[i] <= self.timestamps[i+1] for i in range(len(self.timestamps)-1))
        if not is_sorted:
            print("Warning: Timestamps are not properly sorted!")
        
        if self.timestamps:
            duration = self.timestamps[-1] - self.timestamps[0]
            print(f"Duration: {duration}")
            print(f"Start time: {self.timestamps[0]}")
            print(f"End time: {self.timestamps[-1]}")
        
        print(f"\n{'Memory Statistics (MB)':^80}")
        print(f"{'-'*80}")
        
        # Headers
        print(f"{'Metric':<20} {'Maximum':<12} {'Minimum':<12} {'Average':<12} {'Growth':<12}")
        print(f"{'-'*80}")
        
        # Statistics for each metric type
        metric_types = [
            ('heap_alloc_bytes', 'Heap Allocated'),
            ('heap_inuse_bytes', 'Heap In Use'),
            ('heap_sys_bytes', 'Heap System')
        ]
        
        for metric_key, metric_name in metric_types:
            stats = self.calculate_statistics(metric_key)
            if stats:
                print(f"{metric_name:<20} "
                      f"{stats['maximum']:<12.2f} "
                      f"{stats['minimum']:<12.2f} "
                      f"{stats['average']:<12.2f} "
                      f"{stats['peak_growth']:<12.2f}")
        
        print(f"{'-'*80}")
        
        # Additional insights
        heap_alloc_stats = self.calculate_statistics('heap_alloc_bytes')
        if heap_alloc_stats:
            memory_efficiency = (heap_alloc_stats['average'] / heap_alloc_stats['maximum']) * 100
            print(f"\nMemory Efficiency: {memory_efficiency:.1f}% (avg/peak ratio)")
            
            if heap_alloc_stats['peak_growth'] > 0:
                print(f"Memory Growth Rate: {heap_alloc_stats['peak_growth']:.2f} MB total")
            elif heap_alloc_stats['peak_growth'] < 0:
                print(f"Memory Reduction: {abs(heap_alloc_stats['peak_growth']):.2f} MB total")
            else:
                print("Memory Usage: Stable (no net growth)")
    
    def plot_memory_usage(self, save_plot: bool = True, show_plot: bool = True):
        """Create simplified memory usage plots."""
        if not HAS_MATPLOTLIB:
            print("Matplotlib not available. Skipping plots.")
            return
        
        # Create figure with 2 subplots (1 row, 2 columns)
        fig, axes = plt.subplots(1, 2, figsize=(15, 6))
        fig.suptitle(f'Memory Analysis: {Path(self.filename).name}', fontsize=16, fontweight='bold')
        
        # Plot 1: All memory metrics over time
        ax1 = axes[0]
        metric_types = [
            ('heap_alloc_bytes', 'Heap Allocated', 'blue'),
            ('heap_inuse_bytes', 'Heap In Use', 'red'),
            ('heap_sys_bytes', 'Heap System', 'green')
        ]
        
        for metric_key, label, color in metric_types:
            timestamps, values_mb = self.get_memory_data(metric_key)
            ax1.plot(timestamps, values_mb, label=label, color=color, linewidth=2, marker='o', markersize=3)
        
        ax1.set_title('Memory Usage Over Time')
        ax1.set_xlabel('Time')
        ax1.set_ylabel('Memory (MB)')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        plt.setp(ax1.xaxis.get_majorticklabels(), rotation=45)
        
        # Plot 2: Memory distribution histogram (Heap Allocated only)
        ax2 = axes[1]
        _, heap_alloc_mb = self.get_memory_data('heap_alloc_bytes')
        if heap_alloc_mb:
            ax2.hist(heap_alloc_mb, bins=20, alpha=0.7, color='skyblue', edgecolor='black')
            avg_memory = sum(heap_alloc_mb) / len(heap_alloc_mb)
            ax2.axvline(avg_memory, color='red', 
                       linestyle='--', label=f'Average: {avg_memory:.1f} MB')
        
        ax2.set_title('Memory Usage Distribution (Heap Allocated)')
        ax2.set_xlabel('Memory (MB)')
        ax2.set_ylabel('Frequency')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_plot:
            output_file = f"memory_analysis_{Path(self.filename).stem}.png"
            plt.savefig(output_file, dpi=300, bbox_inches='tight')
            print(f"\nPlot saved as: {output_file}")
        
        if show_plot:
            plt.show()
        else:
            plt.close()


def main():
    """Main function to run the memory analysis."""
    parser = argparse.ArgumentParser(
        description="Analyze memory monitoring data from Weaviate benchmarker",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python memory_analysis.py results/memory_metrics_1234567890.json
  python memory_analysis.py memory_data.json --no-plot
  python memory_analysis.py memory_data.json --save-only

Output:
  - Statistics: max, min, average, and growth for all memory metrics
  - Plot 1: Memory usage over time (all metrics: heap_alloc, heap_inuse, heap_sys)
  - Plot 2: Memory usage distribution histogram (heap_alloc only)
        """
    )
    
    parser.add_argument('filename', help='Path to the memory metrics JSON file')
    parser.add_argument('--no-plot', action='store_true', 
                       help='Skip generating plots (statistics only)')
    parser.add_argument('--save-only', action='store_true',
                       help='Save plots but don\'t display them')
    
    args = parser.parse_args()
    
    try:
        analyzer = MemoryAnalyzer(args.filename)
        
        analyzer.print_statistics()
        
        if not args.no_plot:
            show_plot = not args.save_only
            analyzer.plot_memory_usage(save_plot=True, show_plot=show_plot)
        
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
